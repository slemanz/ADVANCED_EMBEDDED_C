# Linker and Startup

### Memory Model

1. Flash Memory:
    - Read-Only
    - Size depends on specific microcontroller
    - Program code is stored here.
    - Contains a vector table, this consists of pointers to
    the various exception handles.

2. SRAM:
    - Read and Write
    - Begins at 0x20000000
    - Size depends on specific microcontroller
    - Variables and Stack are stored here

## Linker Script

- Script given to the linker in order to specify the memory layout
and to initialize the various memory sections used by the firmware.

- The linker script is responsible for making sure various portions
of the firmware are in their proper place and also for associating
meaningful labels with specific regions of memory used by the startup
code.

**The script has 4 features:**

- Memory Layout : available memory types
- Section Definitions: placing specific parts at specific locations
- Options : commands e.g. ENTRY POINT
- Symbols: variables to inject into program at link time

### Memory

In order to allocate program memory, the linker needs to know the types
of memory, their addresses and sizes. We use the `MEMORY` definition to
provide this information

```
MEMORY
{
    name [(attr)] ORIGIN origin, LENGTH = len
}
```

```
MEMORY
{
    FLASH(rx):ORIGIN =0x08000000, LENGTH =512K
    SRAM(rwx):ORIGIN =0x20000000, LENGTH =128K
}
```

### Sections

Code and data are organized into sections. Symbols of the same memory
region are placed in the same s

```
SECTIONS
{

}
```

```
E.g.
SECTIONS
{
    .text:
    {
        *(.text) /*merge all text sections of input files */
    }> FLASH
}
```

### The 3 relevant sections

- **.text** - Placed in the FLASH
- **.data** - Placed in the SRAM
- **.bss**  - Placed in the SRAM

### VMA and LMA

- **LMA:** Load Memory Address, the address at which a section is loaded.

- **VMA:** Virtual Memory Address, the address of a section during execution.

The Linker distinguishes between the VMA and LMA address.


### Load memory

Flash memory:

```
┌────────────────┐
│                │
│                │
│                │
├────────────────┤
│                │
│    .data       │
│                │
├────────────────┤
│                │
│   .rodata      │
│                │
├────────────────┤
│                │
│    .text       │
│                │
├────────────────┤
│  .isr_vector   │
└────────────────┘ 0x0800 0000
```

In startup code, copy .data from `FLASH` to `SRAM`:

```
┌────────────────┐
│                │
│                │
├────────────────┤
│     .bss       │
├────────────────┤
│     .data      │
└────────────────┘ 0x2000 0000
```

### Some Commands

- **ENTRY**: Sets program entry address.

- **MEMORY**: Describes the locations and sizes of the different
memories available.

- **ALIGN**: Inserts padding to align location.

- **SECTIONS**: Used to map input sections to output sections and
describes how to place output sections in memory.

- **KEEP**: Tells linker to keep the specified section even if no
symbols in that section are referenced.

- **AT >**: This is a directive, it tells the linker to load a section's
data to somewhere other than the address it is located at.

### Constants

- The linker considers an integer with:
    - 0 as Octal
    - Ox as hexadecimal

- Suffixes K and M may be used to scale a constant by 1024 or by
1024*1024 respectively

Different ways of writing the same quantity :

- _four_1 = 4K

- _four_2 = 4096;

- _four_3 = 0x1000;

### Load Memory

```
┌────────────────┐ SRAM
│                │
│                │
├────────────────┤
│     .bss       │
├────────────────┤
│     .data      │
└────────────────┘ 0x2000 0000

┌────────────────┐ FLASH
│                │
│                │
│                │
├────────────────┤
│                │ Copy .data section from FLASH
│    .data       │ to SRAM
│                │
├────────────────┤
│                │
│   .rodata      │
│                │
├────────────────┤
│                │
│    .text       │
│                │
├────────────────┤
│  .isr_vector   │
└────────────────┘ 0x0800 0000
```

### Symbols

- Symbols have a name and a value.
- Symbol values are an unsigned integers.
- Symbols are generated by the compiler for each function and variable D
- The value represent the target address where the variable or function is stored.
- When you refer to the symbol by name in the linker command file or in an assembly
file, you get that integer value.

Example: When we use X in our code we are actually referring to the value of
X which is 3500

`X = 3500`

When we write: `X - Y`

- The compiler fetches 3500
- To achieve this the compiler generates a linker symbol called x with the value &x
- Although the C/C++ variable and the linker symbol have the same name, they don't
represent the same thing.
- In C/C++ x is a variable name with address &x and value 3500
- For the linker symbols x is an address and that address contains 3500

```
┌───────────────────┐
│      main.c       │
├───────────────────┤
│ int x = 3500;     │               ┌─────────────────────┐
│ void blink(void)  │               │     Symbol table    │
│ {                 │               ├────────┬────────────┤
│     led_on();     │─── Build ──>  │ Symbol │ Address    │
│     wait();       │               │   x    │ 0x20000000 │
│     led_off();    │               │ blink  │ 0x08000000 │
│ }                 │               └────────┴────────────┘
└───────────────────┘               
```

Values may be assigned to symbols. This will define them and place them into
the Symbol Table

```
┌────────────────┐ 
│                │
│                │
│                │
├────────────────┤ _edata
│                │
│    .data       │
│                │
├────────────────┤ _sdata
│                │
│   .rodata      │
│                │
├────────────────┤ _etext
│                │
│    .text       │
│                │
├────────────────┤
│  .isr_vector   │
└────────────────┘ 0x0800 0000
```

### The Location Counter

- It is a special linker symbol written as "." dot
- This symbol always contains the current output location counter
- This symbol can only appear inside the `SECTION` command Because it always
refers to a location in an output section
- We can use this symbol to define and know the boundaries of various sections.
- Since symbols are addresses, this symbol is incremented by the size of
the output section.
- This symbol may not be moved backward, i.e. assigned a value lower than the current
output location. Doing this may lead to creating areas of overlapping LMAS

Example of use:

```
SECTIONS
{
    . = 0x08000000;/*Set value of location counter*/
    .text:
    {
    *(.text) /*merge all.text sections of*/
             /*input files */
    }

    . = 0x20000000;
    .data:
    {
    *(.data) /*merge all data sections of*/
             /*input files */
    }
}
```

### Align

To align sections use: `. = ALIGN(X);`

## Startup Code

1. Reset Handler
    - This functions copies the initial values for variables from the
    `FLASH` where the linker places them to the `SRAM`.
    - It also zeros out the uninitialized data portion of the `SRAM`.

2. Interrupt Vector Table

    - This is an array that holds memory address of interrupt handler
    functions
    - In order to allow application code to conveniently redefine the
    various interrupt handlers, every required vector is assigned an
    overideable `_weak` alias to a default function which loops forever.

### Verify custom section

```C
__attribute__((section(".NAME")))
```

```bash
arm-none-eabi-gcc -c startup.c -o startup.o
arm-none-eabi-objdump -h startup.o > startup.txt
```

## Simple example

Generate output files:

```bash
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu99 main.c -o main.o
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu99 startup.c -o startup.o
```

Then, link:

```bash
arm-none-eabi-gcc -nostdlib -T linker.ld *.o -o flash.elf -Wl,-Map=flash.map
```

Dump the files:

```bash
arm-none-eabi-objdump -h main.o > main.txt
arm-none-eabi-objdump -h flash.elf > flash.txt
```

Finally, load with openocd:

```bash
openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg -c init -c "reset init" \
	-c "flash write_image erase flash.elf" -c "reset run" -c shutdown
```

Then, clean *.o files

```bash
rm *.o
```