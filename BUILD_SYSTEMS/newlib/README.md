# Newlib

Newlib is a C standard library designed for embedded systems. It is a collection
of software from various sources, all under free software licenses.

Newlib is known for its portability and is often used in conjunction with GNU
cross-development toolchains. 

The idea of this readme is to document how to implement full linker script, makefile
linker scripts content to implement libc in microcontrollers ARM Cortex-M.

### Syscalls

Newlib is enabled by default when you build a project with arm-none-eabi-gcc.
Indeed, you must explicitly opt-out with `-nostdlib` if you prefer to build your
firmware without it.

The newlib documentation5 calls some functions “system calls”. In short, they
are the handful of things newlib expects the underlying “operating system”. The
complete list follows:

```
_exit, close, environ, execve, fork, fstat, getpid, isatty, kill,
link, lseek, open, read, sbrk, stat, times, unlink, wait, write
```
- **fstat:** returns the status of an open file. The minimal version of this
should identify all files as character special devices. This forces
one-byte-read at a time.

```C
#include <sys/stat.h>
int _fstat(int file, struct stat *st) {
  st->st_mode = S_IFCHR;
  return 0;
}
```

- **lseek:** repositions the file offset of the open file associated with the
file descriptor fd to the argument offset according to the directive whence.
Here we can simply return 0, which implies the file is empty.

```C
int _lseek(int file, int offset, int whence) {
  return 0;
}
```

- **close:** closes a file descriptor fd. Since no file should have gotten
opened, we can just return an error on close:

```C
int _close(int fd) {
  return -1;
}
```

- **write:** writes up to count bytes from the buffer starting at buf to the
file referred to by the file descriptor fd. we will want those bytes to be
written to serial instead.

```C
int _write(int file, char *ptr, int len) {
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
  	__io_putchar(*ptr++);
  }
  return len;
}
```

- **read:** attempts to read up to count bytes from file descriptor fd into the
buffer at buf.

```C
int _read(int file, char *ptr, int len) {
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++)
    {
    	*ptr++ = __io_getchar();
    }
    return len;
}
```

- **sbrk:** increases the program’s data space by increment bytes. In other
words, it increases the size of the heap.

```C
caddr_t _sbrk(int incr)
{
    extern char end asm("end");
    static char *heap_end;
    char *prev_heap_end;

    if (heap_end == 0)
    	heap_end = &end;

    prev_heap_end = heap_end;
    if (heap_end + incr > stack_ptr)
    {
    	errno = ENOMEM;
    	return (caddr_t) -1;
    }

    heap_end += incr;

    return (caddr_t) prev_heap_end;
}
```

The other functions simple implementation can be found in the file
[syscalls.c](Linkers/syscalls.c). Also can be found more details in the
official documentation from newlib: [newlibc](https://sourceware.org/newlib/).

### Linker

By default, GCC places all program code into a section named ".text" and
read-only data (such as const static variables) into a section named ".rodata"
in the input object files. This naming convention is from the ELF ABI
specification.

When you build with newlib, a new sections are generated:

```
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000062a0  08000000  08000000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .init         0000000c  080062a0  080062a0  000162a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  080062ac  080062ac  000162ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .eh_frame     00000004  080062b8  080062b8  000162b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.exidx    00000008  080062bc  080062bc  000162bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .rodata.str1.4 00000142  080062c4  080062c4  000162c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         000001dc  20000000  08006406  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  200001dc  080065e2  000201dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  200001e0  080065e6  000201e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000d8  200001e8  080065ea  000201e8  2**3
                  ALLOC
 10 ._user_heap_stack 00000600  200002c0  080065ea  000202c0  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  000201e4  2**0
```

The file **[linker.ld](Linkers/linker.ld)** shows one complete linker script
which merge all sections generated by newlib and also from c++ posible code.

### Startup

The startup must have the `__libc_init_array();` function, looking the
Reset_Handler something like:

```C
void Reset_Handler(void)
{
    copy_data();
    clear_bss();

    __libc_init_array();

    main();
}
```

The file **[startup.c](Linkers/startup.c)** have a complete implementation.

### Constructors in C

The GNU compiler collection and Newlib offer an alternative solution:
constructors. Constructors are functions which should be run before main.
Conceptually, they are similar to the constructors of statically allocated C++
objects. A function is marked as a constructor using the attribute syntax:
`_attribute__((constructor))` .

The file **[constructors.c](Linkers/constructors.c)** show a full example of
uart init and also retarget the printf.

---

### References

[The most thoroughly commented linker script (probably)](https://blog.thea.codes/the-most-thoroughly-commented-linker-script/)

[From Zero to main(): Bootstrapping libc with Newlib](https://interrupt.memfault.com/blog/boostrapping-libc-with-newlib)

[How a Microcontroller starts](https://www.youtube.com/watch?v=MhOba73z-dQ&ab_channel=ArtfulBytes)

